GRASP (General Responsibility Assigment Software Patterns - общие шаблоны распределения обязанностей):

1. Information Expert (Информационный эксперт)

    Этот шаблон определяет базовый принцип назначения обязанностей: обязаннсть должна быть назначена тому объекту, который владеет
        максимумом необходимой информации для её выполнения - и такой объект называется ИНФОРМАЦИООНЫМ ЭКСПЕРТОМ.

2. Creator (Создатель)

    Шаблон определяет, кто должен создать объект (фактически. это применение шаблон "Информационный эксперт" к проблеме
    создания объектов): целесообразно назначить классу "В" обязанность создавать экземпляр класса "А", если "В" производит
    следующие действия по отношению к "А":

        + Содержит или агрегирует;
        + Записывает;
        + Активно использует;
        + Обладает данными инициализации.

    Альтернативой является шаблон проектирования "Фабрика" (создание объектов концентрируется в отдельном классе).

3. Controller (Контроллер)

    Отвечает за операции, запросы на которые приходят от пользователя, и может выполнять сценарии одного или нескольких
        вариантов использования (например, создание и удаление);

    Не выполняет работу самостоятельно, а делегирует компетентным исполнителям;

    Может представлять собой:
        + систему в целом;
        + подсистему;
        + корневой объект;
        + устройство.

    Вася -> Отправить форму -> $_POST -> Контроллер -> $chat->addMessage($_POST['userFrom'], $_POST['userTo'], $_POST['message'])
                                            $result <-
                                                    -> Представление->render($result)

4. Low Coupling (низкая связанность)

    Между модулями должна быть низкая связанность
    см. картинку в lesson05/01/04/low_coupling.png
    распределение ответственностей и данных, обеспечивающее взаимную независимость классов. Класс со «слабым» зацеплением:

        Имеет слабую зависимость от других классов;
        Не зависит от внешних изменений (изменение в одном классе оказывает слабое влияние на другие классы);
        Прост для повторного использования.

5. High Cohesion (Высокая степерь зацепления)

    а внутри каждого модуля / класса связанность методов должна быть высокая, так сказать на одной волне.

6. Polymorphism (Полиморфизм)

    Полиморфизм позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия
        при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) по разному
        несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding).

7. Pure Fabrication (Чистая выдумка)

    Здесь суть в выдуманном объекте. Аналогом может быть шаблон Service (сервис) в парадигме DDD.

    Какую проблему решает Pure Fabrication?
        * Уменьшает зацепление ( Low Coupling);
        * Повышает связанность (High Cohesion) ;
        * Упрощает повторное использование кода.

    Не совсем понятно?
    Давайте рассмотрим пример и все станет на свои места ^_^
    К примеру у вас есть объект Customer и следую шаблону  информационный эксперт вы наделили его логикой которую мы показывали выше,
        как вы реализуете сохранение Customera в БД? Так вот следуя Pure Fabrication принципу, мы создадим Сервис или
        репозиторий который будет доставать и сохранять такой объект в базу данных.
    

8. Indirection (Посредник|Перенаправление)

    Можно столкнуться с таким вопросом: «Как определить ответственность объекта и избежать сильной связанности между объектами,
        даже если один класс нуждается в функционале (сервисах), который предоставляет другой класс?»

    Решение: возложите ответственность на промежуточный объект, чтобы он осуществлял связь между другими компонентами
        или службами, чтобы они не были напрямую связаны. Такое решение можно сделать с помощью GoF паттерна медиатор


9. Protected Variations (Устойчивый к изменениям)

    Шаблон защищает элементы от изменения другими элементами (объектами или подсистемами) с помощью вынесения взаимодействия в
        фиксированный интерфейс, через который (и только через который) возможно взаимодействие между элементами.
        Поведение может варьироваться лишь через создание другой реализации интерфейса.

    Проблема: Как спроектировать объекты, подсистемы и системы таким образом, чтобы изменения или нестабильность этих элементов
        не оказывали нежелательного влияния на другие элементы?

    Решение: Определите точки прогнозируемого изменения или нестабильности, распределите обязанности по созданию стабильного интерфейса вокруг них.
    По мнению многих это самый важный принцип который косвенно связан с остальными принципами GRASP. В настоящее время одним из наиболее
        важных показателей качества кода является простота изменений. Как архитекторы и программисты,
        мы должны быть готовы к постоянно меняющимся требованиям. Это не является «nice to have» атрибутом - это «must-have» в любом приложении и
        наша обязанность как программистов и архитекторов нашей системы это обеспечить.


    К примеру, в папке vendor/ изменять код библиотеки нельзя, поэтому менять поведение библиотеки можно только с помощью
    плагиной, или с помощью наследования.



Шаблоны GRASP - это хорошо документироованные, стандартизированные и проверенные временем принципы
    объектно-ориенированного анализа.



